## %#################################################/all.copies.successiveBlastx_noRateau.out#####%##
#                                                           #
####  This script blasts TE copies against the database  ####
#### of repeat proteins to find protein regions in TEs.  ####
#                                                           #
## %######################################################%##
# this script is executed at stage 6 of the pipeline 


# As a single copy may encompass several proteins (in particular, for
# retrotransposons), we blast copies once to retain only the best hit per copy,
# then we extract TE parts that are not in HSPs, and blast them again. Five
# "rounds" of blast searches are performed. We do that rather than retrieving
# many hits per TE in a single blast because this gives not guaranty to find all
# the proteins of the TE (most of the hits would be likely to involve the same TE
# region that aligns on homologous proteins of repbase).

# but doing so require blasting sub-part of copies, and some particular care
# about blast coordinates, which will have to be converted to coordinates
# in the reference of the original copy

library(stringr)
library(parallel)

source("HTvFunctions.R")

##### FUNCTIONS for which one has to do some modifications ####

# MODIFY this function to have the right path for diamond
# ATTENTION diamond has to be >= v2.0.7
# NOTE When I used on older version, long sequences led to segmentation fault
# In this study, we used v2.0.14
seqtkDiamond <- function(fas, bed, db, out) {
    # extract sequences from fasta file "fas" using bedfile "bed" and blasts
    # them against a diamond protein database "db", to output file "out"
    system(
        paste(
            "seqtk subseq",
            fas,
            bed,
            "| diamond blastx -p 1 --sensitive -d", #
            db,
            "--quiet -k 1 -f 6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qlen -o",
            out
        )
    )
    
  
    if ((file.size(out) > 0) == TRUE) {
        # because fread() cannot read empty files
        return(fread(out, header = F, sep = "\t"))
        
    } else {
        # returns an empty table if there is not hit
        return(data.table())
    }
}


###################################################

# the only argument is the number of CPUs to use
args <- commandArgs(trailingOnly = TRUE)
nCPUs <- as.integer(args[1])

setwd("TEs/") 

# we prepare output folders. The first one is that of blast output for ongoing searches
outFolder <- "blastx/out/"

# and this one is where results will be moved upon completion of the search
doneFolder <- "blastx/done/"
dir.create(doneFolder, recursive = T)
dir.create(outFolder)

# we import bed files of TE copy (or copy parts) to extract 
# from TE fastas (with seqtk), generated by script 06
beds <- list.files("selectedCopies", pattern = ".txt", full.names = T)
beds <- beds[str_detect(beds,"GCA")]
assembly <- str_match(beds, "selectedCopies/\\s*(.*?)\\s*.txt")[,2] 

# generates output file names of finished searches
done <- stri_c(doneFolder, assembly, ".copies.successiveBlastX.out")

# in case the job needs to be relaunched, avoids redoing searches that were already done
f <- !file.exists(done)
assembly <- dt$assembly[f]
file <- dt$file[f]
done <- done[f]

# database of repeat proteins
# it is in the folder findDubious just because we also used it for that
db <- ("../DB_clustered/findDubious/repeatPeps.dmnd")

# below, the function that does the successive blastx searches for a given species. maxRounds will be 5
successiveBlastx <- function(assembly, file, done, maxRounds) {
    
    #we generate file names of TE fasta file and the file listing TE copy names
    fas <- stri_c("../RepeatMasker/copies/", assembly, ".TEs.fasta")
    bed <- stri_c("selectedCopies/", file, ".txt")

    # this empty data table will contains the combined hits of the successive blasts
    combined <- data.table()
    
    for (round in 1:maxRounds) {
    
        print(paste0("Run round ", round, " of ", assembly))

        # generates output file name of current round
        out <- stri_c(outFolder, file, ".round", round, ".out")
        # this extracts TEs (or TE parts) with seqtk and pipes them to diamond blastx
        blast <- seqtkDiamond(fas, bed, db, out)
        if (nrow(blast) == 0) {
            break
        }

        # we combine the current hits with any previous ones and process the output (see processBlastX() function)
        combined <- rbind(combined, processBlastX(blast))
        if (round < maxRounds) {

            # extract TE parts not involved in hits (a bed-like table)
            parts <- unalignedParts(combined)
            if (nrow(parts) == 0) {
                break
            }

            # creates a bed file for these parts
            bed <- stri_c("selectedCopies/", file, ".round", round, ".bed")
            write.table(parts, bed, row.names = F, na = "NA",  sep = "\t", col.names = F, quote=F)

            # and repeats until maxRounds
        }
    }
    
    print(paste0("Writing outputs of ", assembly))

    # writes output to the done/ folder once finished
    write.table(combined, done, col.names = F, na = "NA",  sep = "\t", row.names=F, quote=F)
    
    return(NULL)
}

# the function is applied in parallel for several assembly
m <- mcMap(successiveBlastx,
    assembly = assembly,
    file = file,
    done = done,
    maxRounds = 5,
    mc.cores = nCPUs,
    mc.preschedule = F
)

# we concatenate the output
# these are for the combined outputs of the different rounds
system("cat blastx/done/*.out > blastx/all.copies.successiveBlastx.out")

# and these are the "raw" uncombined outputs (the first lines is because i don't want to cat old files, before rateau)
system("cat blastx/out/*.out > blastx/allRaw.out")
