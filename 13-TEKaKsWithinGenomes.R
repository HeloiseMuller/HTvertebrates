## %######################################################%##
#                                                          #
####    This stage establishes ka ks rate for pairs     ####
####                 of TEs copies that                 ####
####      diverged by transposition within genomes      ####
#                                                          #
## %######################################################%##
# this can in fact be lauchned after step 9 since we only need the information about hit
# communities (first round of clustering), not of hit groups.

# the principle is to compute Ka and Ks values for related copies within a genomes
# These copies belong to the same "community" of hits, so are unlikely to represent
# different htt events. They would have diverged by transposition within the genome

# The input is the list of hits between TEs, only to obtain the communities of hits
# and the self-blastn hits of TE copies against themselves


source("HTvFunctions.R")

# STEP ONE, we select relevant blast hits of TEs to compute ka ks rates. We do it
# per superfamily (for big super families, several blast seaches were performed in
# parallel so there are multiple output files)

# we retreive blastn hits of copies against themselves (generated by
# TEselfBlastn.R at step 8-prepareClustering.R). As these files are very big, we
# firt select only the hits we need. We will then compute Ka and Ks corresponding
# to pairs of copies in these hits
# blast files of copies against themselves
blastFiles <- list.files(
    path = "TEs/clustering/blastn/done",
    pattern = ".out",
    full.names = T
)

# some output file may be empty (no hits), which would cause an issue during import
blastFiles <- blastFiles[file.size(blastFiles) > 0]

# we extract superfamily names from file names
superF <- splitToColumns(basename(blastFiles), "_", 1)

# we split files names per superfamily
blastFiles <- split(blastFiles, superF)

# we import the copy integer identifiers as these are used in blasts, instead of very long copy names
ids <- ids <- fread("TEs/clustering/selectedCopiesKs05occ200.IDs.txt")

# we retreive the host species of copies, as we will only compare copies within the same genome
ids[, c("sp", "name") := .(extractSpeciesNames(copy), copyName(copy))]

# We also import the tree to give integer ids (tip numbers) to species, for speed
tree <- read.tree("timetree.nwk")

# we make the correspondance between the copy id (index of in the vector below, as the id is an integer) and species id
spForCopy <- ids[match(1:max(id), id), chmatch(sp, tree$tip.label)]

# we import the HTT hits (including hitgroups that were not retained by our criteria, just in case we change our filters afterwards)
httHits <- fread("HTThitsAssessed.txt")

# we extract the information we need. We use the "communities", which are clusters of related copies within young clades.
# This should represent copies that result from a single acquisition, and we will use them to compute ka ks from copies
# related by transposition events, avoiding potential HTT
copiesInCom <- httHits[, union(q, s), by = com]

# we also make a vector for the correspondance betweeen a copy (its index) and a community (its value)
comForCopy <- copiesInCom[match(1:max(ids$id), V1), com]

dir.create("TEs/TEevolution/selectedHits/", recursive = T) # where results will go

# we will now select the hits we need process self blastn output --------------------------------------------------------------
# the hits must involve copies from the same community and species (genome)
# we do it per super family as there are no hit between super families (no blast)

selectHits <- function(superF) {
    import <- function(file) { # imports and filters a blast file of copies against themseves
        hits <- fread(
            input = file,
            header = F,
            drop = c(3, 9),
            col.names = c("q", "s", "length", "qStart", "qEnd", "sStart", "sEnd"),
            nThread = 1
        ) # since the function will be launched in parallel, we don't need several threads

        # we may already select hits that are long enough for Ka Ks computations
        hits <- hits[length >= 300L]

        # abd select hits between copies from the same species
        hits <- hits[spForCopy[q] == spForCopy[s] &
            comForCopy[q] == comForCopy[s], ] # and same community

        cat(".") # progress indicator (the files are big, this takes time)
        hits
    }

    # we apply the above function in parallele using 20 processes
    # and rbind filtered blast hits from the same super family
    rbindlist(mclapply(
        X = blastFiles[[superF]],
        FUN = import,
        mc.cores = 20,
        mc.preschedule = F
    ))
}


# we apply the function for all super families
# which are names of the blastFile list
intraGenomeHits <- rbindlist(lapply(names(blastFiles), selectHits))

# we write the select hits do disk
writeT(
    data = intraGenomeHits,
    path = "TEs/TEevolution/selectedHits/all.out"
)



# STEP TWO, we filter TE hits that cover a protein region of at least 300 bp-------------------------------------------------
# this is to avoid unnecessary ka/ks computations on codon alignments that will be too short

# we import the a blastx file generated earlier (step 6), listing
# alignment coordinates of copies against repeat proteins
# this one doe not have overlapping HSPs
blastx <- fread("TEKs/blastxOCC2000EXcov1.out")

# we replace copy names by their integer ids, since ids are used in the self blastn files
blastx[, id := ids[chmatch(blastx$copy, name), id]]

# we only retain blastx results for copies involved in our selected hits against themselves
# this will speed things up a bit
blastx <- blastx[id %in% intraGenomeHits[, union(q, s)]]

# as there are several HSPs (aligments) per TE, we get the minimal start
# and maximal end of these, to approximate the protein region covered by a TE
blastxCoords <- blastx[, .(start = min(start), end = max(end)), by = id]

# we addp column of TE hit coordinates where starts always < ends
intraGenomeHits[, c(
    "qSt", "qEn",
    "sSt", "sEn"
)
:= data.table(
        fixRanges(cbind(qStart, qEnd)),
        fixRanges(cbind(sStart, sEnd))
    )]

# we add protein ranges for query and subject in blastn hits
intraGenomeHits[, c("qSprot", "qEprot") := blastxCoords[match(q, id), .(start, end)]]
intraGenomeHits[, c("sSprot", "sEprot") := blastxCoords[match(s, id), .(start, end)]]

# we obtain the region of the TE query that aligns on the TE subject and also aligns on proteins
intraGenomeHits[, c("qSprot", "qEprot") := data.table(intersection(qSt, qEn, qSprot, qEprot, T))]

# same for the subject TE
intraGenomeHits[, c("sSprot", "sEprot") := data.table(intersection(sSt, sEn, sSprot, sEprot, T))]

# we convert the above into query coordinates
intraGenomeHits[, c("qsS", "qsE") := .(qSt + sSprot - sSt, qEn + sEprot - sEn)]

# we estimate the length of the protein part of copies that align with each other
intraGenomeHits[, inter := pmin(qEprot, qsE) - pmax(qSprot, qsS) + 1L]

# selects hits for which this region is at least 300 bp, and the columns we need
# we also retreive full TE names as these will be needed for Ka Ks computation, as
# these names are used in the fasta files of copy sequences
intraGenomeHits <- intraGenomeHits[inter >= 300L, data.table(q, s,
    query = ids[match(q, id), name],
    subject = ids[match(s, id), name],
    qStart, qEnd, sStart, sEnd
)]

# we prepare the files needed for the TEKaKs.R script
TEhitFile <- "TEs/TEevolution/selectedHits/selected.out"
blastxFile <- "TEs/TEevolution/selectedHits/blastx.out"

# for these tables, we remove copy integer ids, as they are not used in the script
writeT(intraGenomeHits[, -c("q", "s")], TEhitFile)
writeT(blastx[, -"id"], blastxFile)




# STEP THREE, we compute Ka and Ks rates -------------------------------------------------------------

outFolder <- "TEs/TEevolution/Ks"
dir.create(outFolder)
nCPUs <- 30

system(paste(
    "Rscript TEKaKs.R",
    TEhitFile, blastxFile,
    "TEs/clustering/selectedCopiesKs05occ200.fas", # the fasta file of copy sequences
    outFolder, nCPUs
))


# imports results generated by the script above to merge ka ks values with the TEhit table
KaKs <- fread(stri_c(outFolder, "/allKaKs.txt"))

intraGenomeHits[, hit := 1:.N] # required for the merged below, as the kaks results have a hit identifier
KaKs <- merge(
    x = intraGenomeHits[, -c("query", "subject")],
    y = KaKs,
    by = "hit"
)


setnames(KaKs,
    old = c("q", "s"),
    new = c("query", "subject")
)

# we add columns for superfamily names and community ids based on copy ids
ids[, superF := stri_extract_last(copy, regex = "[^#]+")]
KaKs[, c("superF", "com") := .(
    ids[match(query, id), superF],
    comForCopy[query]
)]


writeT(
    data = KaKs[, -c("hit", "qStart", "qEnd", "sStart", "sEnd")],
    path = "TEs/TEevolution/TEKaKsWithinGenomes.txt"
)
