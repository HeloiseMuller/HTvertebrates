##%######################################################%##
#                                                          #
####    This stage establishes ka ks rate for pairs     ####
####                 of TEs copies that                 ####
####      diverged by transposition within genomes      ####
#                                                          #
##%######################################################%##


source("HTvFunctions.R")

# we retreive blastn hits of copies against themselves (generated by
# TEselfBlastn.R at step 8-prepareClustering.R). As these files are very big, we
# firt select only the hits we need we will then compute Ka and Ks corresponding
# to pairs of copies in these hits

blastFiles = list.files("TEs/clustering/blastn/done",
                        pattern = ".out",
                        full.names = T)		#blast files of copies against themselves
blastFiles = blastFiles[file.size(blastFiles) > 0]				#some output file may be empty, which would cause an issue during import
superF = splitToColumns(basename(blastFiles), "_", 1)				#extracts superfamily names from file names
blastFiles = split(blastFiles, superF)							#we will work by superfamily
ids = ids = fread("TEs/clustering/selectedCopiesKs05occ200.IDs.txt")		#copy integer identifiers (as these are used in blasts, instead of very long copy names)
ids[, c("sp", "name") := .(extractSpeciesNames(copy), copyName(copy))]							#retreive the host species of copies, as we will only compare copies within the same genome
tree = read.tree("timetree.nwk")								#imports the tree to give integer ids (tip numbers) to species, for speed
spForCopy = ids[match(1:max(id), id), chmatch(sp, tree$tip.label)]	#this vector will make the correspondance between the copy id (position of in the vector, as the id is an integer) and species id

httHits = fread("HTThitsAssessed.txt")							#HTT hits (including hitgroups that were not retained by our criteria, just in case we change our filters afterwards)
copiesInCom = httHits[, union(q, s), by = com]		#extracts the information we need. We use the "communities", which are clusters of related copies within small clades. This should represent copies that result from a single acquisition, and we will use them to compute ka ks from copies related by transposition events, avoiding potential HTT
comForCopy = copiesInCom[match(1:max(ids$id), V1), com]

dir.create("TEs/TEevolution/selectedHits/", recursive = T)

select = function(superF) {
  #selects relevant blast hits of TEs to compute ka ks rates. We do it per
  #superfamily (for big super families, several blast were performed in parallel
  #so there are multiple output files)
  import = function(file) {
    #imports a blast file of copies against themseves
    dt = fread(
      file,
      sep = "\t",
      header = F,
      drop = c(3, 9),
      nThread = 1
    )
    dt = dt[V4 >= 300L]		#selects hits that are long enough for Ka Ks computations
    dt = dt[spForCopy[V1] == spForCopy[V2] &
              comForCopy[V1] == comForCopy[V2], ]		#selects only hits between copies from the same species and community
    cat(".")							#progress indicator (the files are big, this takes time)
    dt
  }
  rbindlist(mclapply(
    blastFiles[[superF]],
    import,
    mc.cores = 20,
    mc.preschedule = F
  )) 			#rbinding filtered blast results from the same super family
}

TEhits = rbindlist(lapply(names(blastFiles), select))		#applying the funcion for all super families
writeT(TEhits, "TEs/TEevolution/selectedHits/all.out", col.names = F)


############### to avoid unnecessary ka/ks computations, we select TE hits that
############### cover a protein region of sufficient length (â‰¥ 300 bp), similar
############### to what we did in step 6
blastx = fread("TEKs/blastxOCC2000EXcov1.out")					#imports a blastx file generated earlier (step 6), listing alignment coordinates of copies against repeat proteins
blastx[, id := ids[chmatch(blastx$copy, name), id]]				#and replace copy names by their integer ids, since ids are used in the self blastn files
blastx = blastx[id %in% TEhits[, union(V1, V2)]]					#only retain blastx results for copies involved in our selected hits of copies against themselves
blastxCoords = blastx[, .(start = min(start), end = max(end)), by = id]	#as there are several HSPs (aligments) per TE, we get the minimal start and maximal end of these, to approximate the protein region in a TE


TEhits[, c("qSt", "qEn", "sSt", "sEn") := data.table(fixRanges(cbind(V4, V5)), fixRanges(cbind(V6, V7)))]		# = TE hit coordinates where starts always < ends
TEhits[, c("qS", "qE") := blastxCoords[match(V1, id), .(start, end)]]											#we add protein ranges for query and subject in blastn hits
TEhits[, c("sS", "sE") := blastxCoords[match(V2, id), .(start, end)]]
TEhits[, c("qS", "qE") := data.table(intersection(qSt, qEn, qS, qE, T))]										#the region of the query that aligns on the subject and also aligns on proteins
TEhits[, c("sS", "sE") := data.table(intersection(sSt, sEn, sS, sE, T))]										#same for the subject
TEhits[, c("qsS", "qsE") := .(qSt + sS - sSt, qEn + sE - sEn)]												#converts the above into query coordinates
TEhits[, inter := pmin(qE, qsE) - pmax(qS, qsS) + 1L]														#gives the length of the protein part of copies that align with each other

TEhits = TEhits[inter >= 300L, data.table(
  q = V1,
  s = V2,
  query = ids[match(V1, id), name],
  subject = ids[match(V2, id), name],
  qStart = V4,
  qEnd = V5,
  sStart = V6,
  sEnd = V7
)]		#selects hits where this region is at least 300 bp, and names the columns we need. 
#We also have to retreive original copy names for the TEKaKs.R script below (which uses a fasta files of original copy names)

writeT(TEhits[, -c("q", "s")], "TEs/TEevolution/selectedHits/selected.out")			#for these files, we remove copy integer ids, as they are not used in the script that computes Ka Ks
writeT(blastx[, -"id"], "TEs/TEevolution/selectedHits/blastx.out")

#we can now compute Ka and Ks rates
dir.create("TEs/TEevolution/Ks")
system(
  "Rscript TEKaKs.R TEs/TEevolution/selectedHits/selected.out TEs/TEevolution/selectedHits/blastx.out TEs/clustering/selectedCopiesKs05occ200.fas TEs/TEevolution/Ks/ 30"
)
KaKs = fread("TEs/TEevolution/Ks/allKaKs.txt")		#imports results generated by the script above to merge ka ks values with the TEhit table

TEhits[, hit := 1:.N]			#required for the merged below, as the kaks results have a hit identifier
KaKs = merge(TEhits[,-c("query", "subject")], KaKs, by = "hit")
setnames(KaKs, c("q", "s"), c("query", "subject"))
ids[, superF := stri_extract_last(copy, regex = "[^#]+")]
KaKs[, c("superF", "com") := .(ids[match(query, id), superF], comForCopy[query])]			#retreives superfamily names and community ids based on copy ids
writeT(KaKs[, -c("hit", "qStart", "qEnd", "sStart", "sEnd")], "TEs/TEevolution/TEKaKsWithinGenomes.txt")
