## %######################################################%##
#                                                          #
####           This stage computes Ks between           ####
####        species for core genes extracted by         ####
####             BUSCO, in order to compare             ####
####           Ks between TEs and core genes            ####
#                                                          #
## %######################################################%##

# the principle of the approach is described in Peccoud et al. 2017 PNAS


# this script uses the fasta files of complete BUSCO genes in each species in a "BUSCO_results" folder 
# (The BUSCO pipeline was not automated in scripts)
# each file path  must contain the name of a species corresponding exactly to a tip name of timetree.nwk

# example of BUSCO run (launched from bash):
# BUSCO_v3/scripts/run_BUSCO.py -i genomes/Numida_meleagris/Numida_meleagris.fa -o Numida_meleagris.fa -l database/busco/aves_odb9/ -m genome -c 1 -t 10.busco/output/tmp/

# the outputs are (intermediate files not listed):
# - a tabular file of Ka and Ks values for pairs of BUSCO genes from different species "Ks200AAnoRedundancy.txt"
# - figure S2 of the paper (correlation between Ks and divergence time of species) "figureS2.pf"


source("HTvFunctions.R")



# STEP ONE, we perform diamond blastp search of BUSCO proteins to find orthologs between which we compute Ks, and to align proteins afterwards ---------------------------------------
# for this, we do reciprocal blastp search for each pair of species, only retaining the best hit per query

# we will also use the blastp hps coordinates to align proteins 
# at step 2 since Ka Ks computations are are based on codons


# we first retrieve the BUSCO CDS sequences --------------------------------------------

# we list folders assumed to contain BUSCO results:
folders <- list.dirs("BUSCO_results")

# we get each folder of complete CDS that BUSCO must have generated
folders <- folders[grep("single_copy_busco_sequences", folders, fixed = T)]

# where the BUSCO CDS fasta files were go (one file per species), this is done by the function below
dir.create("CDS")

# we obtain the BUSCO CDS sequence for all species with 10 parallel jobs
m <- mclapply(
    X = folders,
    FUN = getBUSCOs,   # see HTvFunctions.R for the definition of this function
    mc.cores = 10,
    mc.preschedule = F
)


# we translate CDS into proteins ---------------------------
# we list fastas of BUSCO CDS generated by the above command
CDSfiles <- list.files("CDS", pattern = ".CDS.fas", full.names = T)
aaFiles <- gsub(".CDS.fas", ".aa.fas", CDSfiles)

# to avoid redoing translations that were already done if the job needs to be relaunched
f <- !file.exists(aaFiles)

# we translate the BUSO CDS into proteins in parallel jobs is done by the function below
# this functions writes a single fasta for all the CDS of a given species
# and returns a summary about the presence of internal stop codons (which may happen)
translationSummary <- mcMap(
    f = translateCDS,  # see HTvFunctions.R for the definition of this function
    cds = CDSfiles[f],
    aa = aaFiles[f],
    mc.cores = 10,
    mc.preschedule = F
)


# we stack the reports about stop codons generated in a single table
translationSummary <- rbindlist(translationSummary)

# we add a column for species names, which we extract from sequence names
translationSummary[, sp := extractSpeciesNames(cds)]

writeT(translationSummary, "CDS/CDS_translation_summary.txt")


# we make diamond blastp databases, one per species --------------------------------------------

# where the blastp output will go
dir.create("Ks/blastp", recursive = T)

# we create one subfolder per species
folders <- stri_c("Ks/blastp/", extractSpeciesNames(aaFiles))

# paths to diamond database to be generated
dbs <- stri_c(folders, "/", extractSpeciesNames(aaFiles), ".dmnd")
lapply(folders, dir.create)

# to avoid re-making databases if the script is relaunched
f <- !file.exists(dbs)

# the function below makes a diamond db
makedb <- function(folder, db, fas) {
    system(paste(
        "diamond makedb --in",
        fas,
        "-d",
        db
    ))
}

# we apply the function in parallel with 10 CPUs
m <- mcMap(makedb,
    folders[f],
    dbs[f],
    AAfiles[f],
    mc.cores = 10,
    mc.preschedule = F
)


# defining pairwise diamond blastp searches between species -------------------------------------
# we use the timetree to reduce the number of searches. HTT is not inferred between closely related species,
# and there is no need to measure Ks in all possible species pairs between two large clades (only a subset of species is used)

tree <- read.tree("timetree.nwk")

# the matrix of divergence time between every tip (as a row and column index)
distMat <- cophenetic(tree)

# the matrix listing the MRCA of every tip (as a row and column index)
mrca <- mrca(tree)

# we turn these matrices into a data table for every species pair
pairs = setNames(data.table(as.table(distMat), as.vector(mrca)), 
                 c("sp1","sp2","divTime","mrca"))

# we list species for which we have translated BUSCO (at least one did not have annotated genes)
aaFiles <- list.files("CDS", pattern = "aa.fas", full.names = T)
aaSpecies <- extractSpeciesNames(basename(aaFiles))

# we only retain pairs of species that have BUSCO genes
pairs <- pairs[sp1 %chin% aaSpecies & sp2 %chin% aaSpecies]


# we generate file names for every blastp seach. First, the database
pairs[, db := stri_c("Ks/blastp/", sp1, "/", sp1, ".dmnd")]

# then the output
pairs[, out := stri_c("Ks/blastp/", sp1, "/", sp2, ".on.", sp1, ".out")]

# then the inputs
pairs[, aa := stri_c("CDS/", sp2, ".aa.fas")]

# and the daa files for diamond
pairs[, daa := stri_c("Ks/blastp/", sp1, "/", sp2, ".on.", sp1, ".daa")]

# for clades older than 500 My, which are very large, we do not compute Ks between all species as it is overkill.
# We will select one species per smaller "young" clades of <=30 My, based on the number of BUSCO detected in its genome

# we retrieve all these young clades with their species (see function in HTvFunctions.R)
youngClades <- cladesOfAge(tree, 30, withTips = T)

# number of translated BUSCO cds for these species
youngClades[, nCDS := translationSummary[match(tip, sp), nseq - stops]]

# we put species that have more BUSCO genes on top
setorder(youngClades, -nCDS)

# so we may ignore all the other species for each clade
toIgnore <- youngClades[duplicated(node), tip]

# if the divergence of clades is >=500 My, we use only one species per young subclade, else we use all species,
# except when the divergence is <80 My (which we discard)
pairs <- pairs[(divTime >= 500 &
    !sp1 %chin% toIgnore &
    !sp2 %chin% toIgnore) | (divTime > 80 & divTime < 500)]

# we create 10 batches of blastp jobs (again, using an sarray of jobs would probably have been better):
pairs[!file.exists(out), batch := rep(1:10, length.out = .N)]
writeT(pairs, "pairsToBlastp.txt")

# jobs are launched manually
# example of the 1st job with 30 CPUs
system('sbatch --mail-type=BEGIN,END,FAIL --cpus-per-task=30 --mem=50G --wrap="Rscript coreGenesblastp.R 1 30"')





# STEP TWO computing and processing Ks values from blastp results (with 30 CPUs) -----------------------------------------
system("Rscript coreGenesKaKs.R 30")

# establishing Ks distribution between sister clades from Ks obtained -------------------------

# we import all results off KaKs computations
Ks <- fead("Ks/KaKs/all.KaKs.txt", header = T)

# extracts species names from sequence names
Ks[, sp1 := extractSpeciesNames(query)]
Ks[, sp2 := extractSpeciesNames(subject)]

# determining the MRCA (node/clade number) for all pairs of species, 
# which we will use to establish the distribution of Ks values for each clade
# so we add the MRCA (clade) of each species pair as a new column.
Ks[, clade := mrca[cbind(sp1, sp2)]]
# These two species de facto belong to the two sister clades that diverged from this MRCA.
# So the "clade" column also designates the two sister clades composing it

# For a pair of sister clades comprising many species, the same BUSCO (of a given species) yielded many Ks values.
# To reduce the pseudo-replication, we retain one Ks value per busco gene per species, using its longest alignment.

# for thise, we put the longest alignments on top
setorder(Ks, -alnLength)

# and retain alignments longer than 200 aa and no more than one alignment per BUSCO gene per clade
Ks <- Ks[alnLength > 200 &
    !duplicated(data.table(clade, subject)) &
    !duplicated(data.table(clade, query))]


# adds the divergence time of each pair of species, for later use
Ks[, divTime := distMat[cbind(sp1, sp2)]]

writeT(Ks, "Ks200AAnoRedundancy.txt")



# making figure S2 to illustrate the rate of synonymous molecular evolution ---------------------------

# We generate divergence time classes within which we compute average Ks (all species pairs considered).

# We use sqrt() to have shorter intervals for low divergence times
timeRanges <- seq(0, sqrt(max(Ks$divTime, na.rm = T) + 1), length.out = 20)^2
# (using quantile() to generate breaks yields too many points at low divergence times, so the plot looks biased)


# assigns divergence times to the classes
Ks[, range := .bincode(divTime, timeRanges)]
KsDistrib <- Ks[Ks < 9 &

    # ignoring Ks values â‰¥ 9 (oversaturated)
    !is.na(divTime), .(time = mean(divTime), Ks = weighted.mean(Ks, w = alnLength)), by = range]

pdf("figure S1.pdf")
p <- KsDistrib[, plot(
    x = time,
    y = Ks,
    ylim = c(0, 3),
    xlab = "Divergence time (My)",
    ylab = "Ks",
    pch = 16,
    col = "darkgrey"
)]

# fits a curve assuming initial linear correlation between Ks and divergence time (coeff a) and saturation at Ks = max
fit <- nls(Ks ~ max * a * time / (max + a * time),
    data = KsDistrib,
    start = list(a = 0.01, max = 3)
)

# to add a smooth curve corresponding to the model, we generate 150 divergence time values (x axis)
x <- KsDistrib[, seq(0, max(time), length.out = 150)]
lines(x, predict(fit, list(time = x)))
dev.off()
