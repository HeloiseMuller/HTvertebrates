

## %######################################################%##
#                                                          #
####          This stage makes figures showing          ####
####       TE composition in species, hit groups,       ####
####           and HTT events (figure 4), and           ####
####         analyses the Ka/Ks ratios of TEs.          ####
#                                                          #
## %######################################################%##


# This can be run at any point after step 13

source("HTvFunctions.R")

# data file provided with the paper, which is a table of hits representing HTT
retainedHits <- fread("supplementary-data4-retained_hits.txt")



# STEP ONE, we collect stats on TE composition in species, to build the barplots (figure 4) ---------------------------------------------------
# we import reports on numbers  of copies of at least 300 bp for the different genomes and 
# super families, generated in step 2
compo <- fread("all.TEcomposition.txt")

# we import the correspondance between repeat modeler super families and more common super family names
corres <- fread(
    "superF.txt",
    header = F,
    col.names = c("superFam", "subClass", "newName")
) 

# we add the super family an subclass names to our per-species table
compo[, c("superfamily", "subClass") := corres[chmatch(superF, superFam), .(newName, subClass)]]
compo[, class := ifelse(subClass == "DNA", "DNA", "RNA")]

# we generate the supplementary dataset associated with the paper ------------------
TEcompo <- compo[, .(
    number_of_copies_300bp = sum(nCopies),
    total_nucleotides = sum(bp),
    number_of_families = sum(nFam)
), by = .(species = sp, RepeatModeler_superfamily = superF)]


TEcompo <- TEcompo[number_of_copies_300bp > 0L]


writeT(
    TEcompo,
    "supplementary-data3-TEcomposition_per_species.txt"
) 

# ------------------------------------------


# to make the baplots, we summ counts per super family
perSuperF <- compo[, .(
    nCopies = sum(nCopies),
    nFam = sum(nFam),
    bp = sum(as.numeric(bp))

    # 
), by = .(superfamily, subClass, class)]


# we count hit groups and independent htt event per superfamily
HTTperSuperF <- retainedHits[, .(nTr = length(unique(hitgroup[independent])), 
                                 nHitGroup = length(unique(hitgroup))), by = superfamily]

# the merge below removes super families not involved in HTT since we don't set all = T
perSuperF <- merge(perSuperF, HTTperSuperF, by = "superfamily", all = F)


# we pool super families that are involved in only few HTT, for each TE class
# we define the number of independent transfer below which we pool super families within TE classes
lower <- 10L


# we sum numbers from these pooled superfamilies in a new table
smallFam <- perSuperF[nTr < lower, .(
    nCopies = sum(nCopies, na.rm = T),
    nFam = sum(nFam),
    bp = sum(bp),
    nTr = sum(nTr),
    nHitGroup = sum(nHitGroup)
), by = class]


# we create a table that has the small super families pooled per class
forBarplots <- rbind(
    data.table(
        superfamily = paste("Other", smallFam$class),
        subClass = smallFam$class,
        smallFam
    ),
    perSuperF[nTr >= lower]
) 

# we sort by subclass then number of independent tansfers, for plotting
forBarplots <- forBarplots[order(-class, !grepl("Other", superfamily), subClass, nTr)]

# we set colors. Barplot sectors of DNA transposons have darker colors
palDNA <- c(grey(0.5), brewer.pal(8, "Paired")[c(4, 2)])
palRNA <- c(grey(0.7), brewer.pal(forBarplots[, sum(class == "RNA") - 1L], "Pastel1"))

# we add a new column that tells which color a TE superfamily should have on the plot
forBarplots[, col := c(palRNA, palDNA)]
# we keep this table around as we do not draw the plots yet




# STEP TWO, we process results on Ka/Ks of TEs, to show on the same figure as the barplots -------------------------------------------------

# we import results fom ka ks value between TEs witin communities generated by step 13-TEKaKsWinthinGenomes.R. 
# Ka and Ks between TEs that diverged by HTT are already in the retainedHits table

kaks <- fread("TEs/TEevolution/TEKaKsWithinGenomes.txt")

# we again replace repeatmodeler superfamily names with common names
kaks[, superfamily := corres[chmatch(superF, superFam), newName]]

# rbinding ka ks rates for pairs of copies involved in HTT and within genome in a single table (which will be convenient).
# We have to use the same column names, so a "community" becomes a hit group 
# and the htt column will indicate whether the copies diverged by HTT
allKaKs <- rbind(
    retainedHits[, .(ka = Ka, ks = Ks, length = length.aa, superfamily, hitgroup, independent, htt = T)],
    kaks[com %in% retainedHits$community, .(ka, ks, length, superfamily, hitgroup = com, independent = T, htt = F)]
) 

# we add a column denoting the TE class (ignoring the retrotransposon subclasses)
allKaKs[, class := corres[chmatch(superfamily, newName), ifelse(subClass == "DNA", "DNA", "RNA")]]

# we again pool super families involved in less than 10 independent transfers
allKaKs[superfamily %chin% perSuperF[nTr < lower, superfamily], 
        superfamily := stri_c("Other ", class)]


# we compute density curves of Ka/Ks ratios -----------------------------------

# the function below returns xy coordinates to drawn density curves (of Ka/Ks) 
# that all reach the same height in the Y axis.
# The difference in Y coordinates between super families on the plot will be 1 unit, 
# so the max height is set to 0.45 (since there are 2 mirrored curves per super family).
# w represents the weights (which will be the alignment lengths)
dens <- function(x, w) {
    d <- density(x, weights = w / sum(w), na.rm = T)
    data.table(x = d$x, y = rescale(d$y, c(0, 0.45)))
}

# the x and y coordinates of the density curves (polygons) are placed in a single
# large data table (one row per vertex). For these curves, we use individual
# ka/ks rates (not averages per hit group)
# we will clip the plot at ka/ks = 2.5, so we discard Ka/Ks rates > 5
densities <- allKaKs[ks > 0L & ka / ks < 5, dens(ka / ks, length), 
                     by = .(superfamily, htt, class)]

# we order the curves to match the future barplots
densities <- densities[order(chmatch(superfamily, forBarplots$superfamily), htt)]

# we compute the Y position of each super family on the densiy plots (+1 unit per super family)
densities[, Yoffset := toInteger(superfamily)]

# we add a column denoting the color of ka/ks curves, to match that of barplots. 
# Colors get replicated for each vertex, but we can afford that
densities[, col := forBarplots[chmatch(densities$superfamily, superfamily), col]]

# the curves showing rate of TEs not involved in htt will be drawn negatively
densities[htt == F, y := -y]


# figure 4 of the paper
pdf("figure4.pdf", width = 7, height = 4.5)

# there will be for plots on the figure
par(
    lwd = 0.25,
    bty = "n",
    mfrow = c(1, 4),
    las = 1,
    mai = c(0.6, 0.5, 0.2, 0.2)
)

layout(matrix(rep(1:4, each = 2), nrow = 2), widths = c(1, 1, 1.3, 3))

# border colors will be grey
border <- "grey"

#we draw the firt par blot for TE composition in genomes
forBarplots[, barplot(
    cbind(nCopies / 10^6),
    names.arg = "Copies (millions)",
    xlim = 0:1,
    col = col,
    border = border
)]

# the second barplot for hit group counts
forBarplots[, barplot(
    cbind(nHitGroup),
    names.arg = "Hit groups",
    xlim = 0:1,
    col = col,
    border = border
)]

# the last barplot for htt counts
forBarplots[, barplot(
    cbind(nTr),
    names.arg = "Transfers",
    xlim = 0:1,
    width = 0.6,
    col = col,
    border = border
)]

# we plot Ka/Ks density polygons
# we prepare the empty plot on which polygons will be drawn
plot(
    x = c(0, 2.5),
    y = c(0.5, max(densities$Yoffset + 0.5)),
    type = "n",
    yaxt = "n",
    ylab = "",
    xlab = "Ka/Ks",
    bty = "n"
)

# because we draw the vertical line at ka/ks = 1 behind the polygon
abline(v = 1, lwd = 0.25, col = "grey")

# we now draw the density polygons
# we split density curves per super family
# calling polygon() from the whole datatable does not draw the correct
# density curve for certain super families, sometimes (bug with data.table??)
splitDens = split(densities, f = densities$superfamily)
p = lapply(splitDens, FUN = function(vertices) vertices[,polygon(
    x = x,
    y = y + Yoffset,
    col = col[1],
    border = border,
    lwd = 0.25
    )]
)

# we add Y axis of super family names
p <- densities[!duplicated(superfamily), axis(2, at = Yoffset, labels = superfamily, las = 1)]

dev.off()



# STEP FOUR, we test if Ka/Ks rates in HTT hits are generally lower than 1 within super families --------------------------------------------------------------

# we obtain one value per independent hit group (or community), as ka/ks rates within a tree are not independant.
# Note that we only use independent transfers (+ all communities, since we set independent = T for these)
perHitGroup <- allKaKs[independent == T & ks > 0, .(kaks = weighted.mean(ka / ks, length), 
                                                    ks = weighted.mean(ks, length)), 
                       by = .(superfamily, hitgroup, htt)]

res <- perHitGroup[, .(.N,
                       kaks = mean(kaks),
                       ks = mean(ks),
                       U = wilcox.test(kaks, 
                                       mu = 1, alternative = "less")$statistic,
                       p = wilcox.test(kaks, mu = 1, alternative = "less")$p.value),
                   by = .(superfamily, htt)]

# we reorder the results to match the barplots
res <- res[order(htt,
    chmatch(superfamily, forBarplots$superfamily),
    decreasing = T
)]

# used for table S2 of the supp text.
writeT(res, "tableS2.txt")
