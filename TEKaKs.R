## %##############################################################%##
#                                                                  #
#### This script computes pairwise Ka/Ks  between homologous TEs  ##
#                                                                  #
## %##############################################################%##

# this script is run at step 7 and at step 13

# the input is
# - the path to a file of hits between sequences, with columns query, subject, qStart, qEnd, sStart, sEnd
# - the path to a file of hits between these sequences and proteins. Overlap between HSPs must be removed
# this file must have the columns query, qStart, qEnd, sStart, sEnd. All "query" values l



source("HTvFunctions.R")
library(seqinr)

args <- commandArgs(trailingOnly = TRUE)

# the first argument is the path to a tabular file of TE-TE hits, for which we will compute Ks
TEhitFile <- args[1]

# the second argument is the path to a tabular of of HSPs between these TEs and protein regions,
# it is generated by the other scripts
blastxFile <- args[2]

# fasta of copy sequences to align
fastaFile <- args[3]

# (see 7-TEKsAndHTTfilter.R to see what these files contain)


outputFolder <- args[4]
nCPUs <- as.integer(args[5]) # nb of CPUs to use


# STEP ONE, preparation of the TE-TE copy alignments ---------------------------------------------------------------
# importing input files
TEhits <- fread(TEhitFile)
blastx <- fread(blastxFile)

# to keep track of hits, we assign them an integer identifier in a column
TEhits[, hit := 1:.N]

# selects HSPs for which there is enough protein regions per copy
# we first compute the total length of HSP per copy
covPerCopy <- blastx[, sum(end - start + 1L), by = copy]

# "hits" below are simply row indices of TEhits table
hits <- TEhits[, which(query %chin% covPerCopy[V1 > 30L, copy] & # the copy and subject must have an alignment on protein longer than 30 bp
    subject %chin% covPerCopy[V1 > 30L, copy])]

# we split the work into several batches (jobs)
# number of jobs to run. The size of a batch of hits (2500) must not be too big due to memory constrains.
nJobs <- round(length(hits) / 2500)

# we split the hits in batches for parallel computations.
hits <- splitEqual(sample(hits), n = nJobs)
# Note that we randomize hits (rows) to reduce differences in job durations (as the longer hits were on top of the TEhits table)


seqs <- readDNAStringSet(fastaFile) # we import the TE sequences

# we modify names to match copy names of the TEhits table (the fasta
# file has longer sequences names that also comprise the host species)
names(seqs) <- copyName(names(seqs))

# we extract the parts of sequences involved in TE hits
qSeqs <- TEhits[, subSeq(seqs[query], qStart, qEnd)]
sSeqs <- TEhits[, subSeq(seqs[subject], sStart, sEnd)]

# we splits these subsequences into batches corresponding to the hit batches to be processed in parallel
qSeqs <- lapply(hits, function(batch) qSeqs[batch])
sSeqs <- lapply(hits, function(batch) sSeqs[batch])

# and we do the same for the hits themselve (we only retain coordinates of hits)
TEhits <- lapply(hits, function(batch) {
      TEhits[batch, .(query, subject, qStart, qEnd, sStart, sEnd)]
  })

rm(seqs, covPerCopy) # we reclaim some RAM
gc()

# STEP TWO, TE-TE pairwise sequence alignemnt and Ka/Ks computation ----------------------------------------------------------------

# below is the core function that pair-wise aligns TEs and computes Ka/Ks on a batch of hits (jobs).
KaKsForJob <- function(job) { # the only argument is the job number

    # we align pairs of copies (this uses the Biostrings package)
    aln <- alignWithEndGaps(
        seq1 = qSeqs[[job]],
        seq2 = sSeqs[[job]]
    )

    # we retreive the table of coordinates of hits corresponding to this job
    TEhitBatch <- TEhits[[job]]

    # we determine position of bases within codons --------------------------------

    # splits alignments into a table of individual nucleotides and positions
    # see function definition in HTvFunctions.R
    nuc <- splitAlignment(
        aln = aln,
        coords = TEhitBatch[, .(query, subject, qStart, qEnd, sStart, sEnd)]
    )


    # we determine the blastx HSP that covers each aligned position, for each copy.
    # for this we add a new integer column simply denoting the row index of the hsp in the blastx table
    # alignment positions outside these HSPs will get NA values
    # we begin with the "query" TE
    nuc[, hsp1 := assignToRegion(
        bed = blastx[, .(copy, start, end)],
        pos = .(seq1, pos1)
    )]


    # and the the subject TE copy
    nuc[, hsp2 := assignToRegion(
        bed = blastx[, .(copy, start, end)],
        pos = .(seq2, pos2)
    )]

    # we can already discard positions outside protein HSPs (no evidence that they are in ORFs)
    nuc <- nuc[!is.na(hsp1) & !is.na(hsp2)]

    # we now determine the position in codon ="frame" (1 to 3 or -1 to -3) of each position
    # for this, we need to know the the orientation of the protein in respect to the copy
    # we thus add two logical column that tell whether the blastx HSPs are in reversed (for query and subject)
    nuc[, c("rev1", "rev2") := .(
        blastx[hsp1, rev],
        blastx[hsp2, rev]
    )]

    # we determine the frame for the bases in the "query" base (base1)
    nuc[, frame1 := ifelse(test = !rev1, # if the HSP is "forward orientation)
        yes = (pos1 - blastx[hsp1, protStart]) %% 3L + 1L,
        no = -((blastx[hsp1, protStart] - pos1) %% 3L + 1L)
    )]

    # then for the subject base (base2)
    nuc[, frame2 := ifelse(test = !rev2,
        yes = (pos2 - blastx[hsp2, protStart]) %% 3L + 1L,
        no = -((blastx[hsp2, protStart] - pos2) %% 3L + 1L)
    )]

    # we reverse the frame of the query bases if it is itself reversed in the TE-TE hit
    nuc[TEhitBatch[aln, qStart > qEnd], frame1 := -frame1]

    # same for the subject
    nuc[TEhitBatch[aln, sStart > sEnd], frame2 := -frame2]

    # removes aligned position where the frames (position in codons) don't match
    nuc <- nuc[frame1 == frame2]
    nuc[, c("hsp1", "hsp2", "rev1", "rev2", "frame2") := NULL] # as well as columns that are no longer necessary



    # we discard incomplete codons from alignments.  -----------------------
    # Codons will be identified by integers (first one, second one, etc.)

    # we first determine whenever tha a new codon starts when...
    shift <- nuc[, c(
        T, # it is the very first base of the table or
        abs(diff(frame1)) != 1L | # the absolute difference in "frame" beween sucessive bases is not 1, or
            abs(diff(pos1)) != 1L | # the absolute difference in coordinates in the query copy is not 1, or
            abs(diff(pos2)) != 1L | # same for the subject copy
            diff(aln) != 0
    )] # or if we shift to a different alignment

    # we generate a unique integer for each codon, for to each aligned position
    codon <- cumsum(shift)

    # we retain only complete codons (found 3 times)
    nuc <- nuc[codon %in% which(tabulate(codon) == 3L)]



    # we prepare, then do, the Ka Ks computations -----------------------------
    # we discard alignments that have less than 31 bases
    nuc <- nuc[aln %in% which(tabulate(aln) > 30L)]

    # we concatenate the individual bases back into sequences, in a new table
    flat <- nuc[, .(
        query = stri_flatten(base1),
        subject = stri_flatten(base2),
        frame = frame1[1]
    ), # see why wee need this column, below
    by = aln
    ]

    # we reverse-complement the sequence that are not from the coding strand	(frame is negative)
    flat[frame1 < 0L, c("query", "subject") :=
        .(revCom(query), revCom(subject))]

    # we split the table into individual pairs of sequences
    spl <- split(flat[, cbind(query, subject)], 1:nrow(flat))

    # we produce seqinr alignment objects
    alns <- lapply(spl, seqinrAlignment)

    # and compute Ka and Ks with seqinr
    KaKs <- lapply(alns, kaks)

    # we stack the results into a data.table
    KaKs <- rbindlist(lapply(
        X = KaKs,
        FUN = as.data.table
    ))

    # add columns for hit identifiers and alignment lengths
    KaKs[, c("hit", "length") := .(
        hits[[job]][flat$aln],
        nchar(flat$query)
    )]

    # we write results for safety (we write the combined results at the end)
    writeT(data = KaKs, path = stri_c(outputFolder, "/KaKs.", job, ".txt"))

    KaKs
}

# we apply the above function for the differnet job in parallel
res <- mclapply(
    X = 1:length(TEhits),
    FUN = KaKsForJob,
    mc.cores = nCPUs,
    mc.preschedule = F
)

writeT(
    data = rbindlist(res),
    path = stri_c(outputFolder, "/allKaKs.txt")
)
