## %######################################################%##
#                                                          #
####            This stage filters the hits             ####
####          between TEs of different species          ####
#                                                          #
## %######################################################%##

# because these hits are so numerous, we filter the blastn outputs
# generated at stage 4 before attempting to stack them in a unique table.

# this scipt uses
# - the similarity search output files generated at stage 4 
# - dS values of BUSCO genes obtained at stage 5

# the final output is a tabular files of filtered TE-TE blastn hit

path = "~/Project/"
setwd(path) 

library(data.table)
library(dplyr)
library(ape)
library(stringi)
library(parallel)

source("HTvFunctions.R")


# STEP ONE ----------------------------------------------------------------------------------
# we filter-out all hits whose percentage identity (not dS) is lower than
# 1 - the 0.5% quantile of dS of the corresponding clade pair.
# Hits not passing this filter would have been very unlikely to pass downstream filters based on TE dS
# this stage also also removes any hits involving a TE that belongs to a family
# whose consensus may involve a non-TE gene (see stage 03-findDubiousTEs.R)

# we import the file of core gene dS generated in stage 05-coreGeneKs.R
dS <- fread("Busco/dS/dNdS/dS100AA_filterBusco_median.txt") 

#Delete dS<0 (=dS that could not be computed)
dS <- filter(dS, dSmedian>=0)

#However, we keep dS=9.9999 (when alignement is close to saturation) because real dS is even higher than that

# we compute the 0.5% dS quantile for every clade (actually I try several)
# we will add this quantile to for every species pair that was blasted
mrcaPif = c(unique(filter(dS, divTime<80)$mrca)) #When we solved the rateau, we also solve the Pif, c(368, 369, 479, 477, 478, 374, 489, 488, 409))
quant <- dS[, .(q05 = quantile(dSmedian, 0.005)), by = mrca] 


#plot divtime ~ q
quant <- select(dS, c(mrca,divTime)) %>%
    mutate(., divTime=round(divTime,4)) %>% 
    distinct() %>% 
    left_join(., quant)
quant <- mutate(quant, divPif = ifelse(mrca %in% mrcaPif, TRUE, FALSE))
ggplot(data=quant, aes(x=divTime, y=q05, col=divPif)) + 
    geom_point() + 
    geom_hline(yintercept=0.5)


# to assign species to the clade, we obtain the mrca for each pair of species
tree <- read.tree("datasetTree.nwk")

mrcaMat <- mrca(tree)


# we import the table of pairs of species whose TEs were compared, generated in 4-blastTEs.R
pairs <- fread("pairsToSearch.txt", select = c(1, 2, 3, 4, 5, 6))

# we can now add a column indicating the minimum pID to retain blast hits
#This will be for the 1st filter on q, ie pID < 1-0,5 % quantile of dS of Busco
pairs[, q5 := 100 - 100 * quant[match(mrcaMat[cbind(sp1_name, sp2_name)], mrca), q5]] 

write.table(pairs, "pairsToFilterQ5.txt", quote=F, row.names=F, na="NA", sep='\t')

# we launch the jobs that filters the hits based on the above table, with 10 CPUs
system('sbatch --cpus-per-task=10 --mem=30G --wrap="Rscript 06bis-filterTEblastnHits.R 10"')


# we import filtered hits generated by the script above.
# these have been collapsed in one tabular file (which is quite big)
TEhits <- fread(
    input = "filtered_HitsTE/all.score200.mmseq2.out",
    #input = "filtered_HitsTE/all.quantile005score200.mmseq2.out", #when filter pID>1-quantileBusco
    header = F,
    sep = "\t",
    col.names = c(
        "copie1",       #name of the copie = query
        "copie2",       #name of the other copie = subject
        "pID", "length", "qStart", "qEnd", "sStart", "sEnd", "score",  #standard attributes of the hsp
        "assembly1",     # the host species of the query
        "assembly2"     # and of the subject     
    )
) 

# STEP TWO, we blast TE copies in retained hits against repeat proteins -------------------------------------------
# this is to prepare the computation of dN/dS between TEs (at later stages)
# but it is also used to select hits involving an ORF of sufficient length

# we export TE copies involved in hits to blast against rep proteins
# copies are identified by different fields,
copies <- TEhits[, data.table(
    assembly = c(assembly1, assembly2),        # the host species
    seq = c(copie1, copie2),  # the copy name (contig + coordinates and orientation)
)] 

# copies are typically involved in several hits, so we remove duplicates
copies <- copies[!duplicated(seq)]
copiesPerSpecies <- split(copies$seq, copies$assembly)

# we write the selected copy names to files
# copy names are saved in separate files for each species,
# as the blastx will be run in parallel
dir.create("TEs/selectedCopies")

m <- Map(
    f = write,
    x = copiesPerSpecies,
    file = stri_c("TEs/selectedCopies/", names(copiesPerSpecies), ".txt")
)

# we blast copies against the diamond repeatPep database, as we use this to compute dS between TEs
#ATTENTION: it is important to check the number of outputs in TEs/blastx/done because some files do not work for some reason. In such cases, one has to modify a line in the script 06tris, in the function expectedProtein
system('sbatch --cpus-per-task=10 --mem=50G --wrap="Rscript 06tris-successiveBlastx.R 10"')



# we now use the blastx information to select hits involving protein regions 

# we import the combined blastx results generated above
blastx <- fread(
    input = "TEs/blastx/all.copies.successiveBlastx.out",
    header = T,
    sep = "\t",
    col.names = c(
        "query", "subject", "pID", "length", "mismatch", "gapopen",
        "qStart", "qEnd", "sStart", "sEnd", "evalue", "score"
    )
)

#Get the superfamily name of the TE of repeatPep on which blast
blastx = mutate(blastx, superF_subject = sub(".*#", "", blastx$subject))

# STEP THREE, we select TE-TE hits involving TE protein regions  >= 300 bp,  -------------------------------------------------------------------
# this is to avoid computing unnecessary Ks (since we require kS computed on ≥300 bp)


# we compute the first and last position of all alignments on proteins for each copy,
# which we infer as the protein region of each copy (even if it may encompass several ORFs)
# this is only done for proteins that are of the same super family as the copy (Jean used ex == 2 but since I don't have any confidence in this parameter, I am just going to check that both hit of a same copy are on the same superF of the protein)

#Combine coordinates by copy
#Here we don't really care if the copy has hits on different proteins. This step is just to select coordinates of interest for the next step (better to select too many than not enough)
perCopy <- blastx[ ,
    .( start = min(c(qStart, qEnd)),
        end = max(c(qStart, qEnd)),
        #if all successive blastx are on a TE of the same superfamily, write this superfamily
        #otherwise, write NA
        superF_blastx = ifelse(length(unique(superF_subject))==1, superF_subject, "NA"),
        nBlastx=length(superF_subject)
        ),
    by = query
]

#We remove hits with NA because it means that we their suerfamily is uncertain
perCopy = filter(perCopy, superF_blastx!="NA")

# Save these copies with info about blastx (will be necessary in the script 07-08
perCopy_save <- mutate(perCopy, assembly =  sub("-.*","", query), family = sub(".*/","", superF_blastx))
dir.create("TEs/copies_allblastx")
perCopy_save <- mutate(perCopy_save, sp_family = paste0(assembly, "-", family))
perCopy_save_l <- split(perCopy_save$query, perCopy_save$sp_family)
fileNames <- stri_c("TEs/copies_allblastx/", names(perCopy_save_l), ".txt")

#Write bed files
m <- Map(
    f = write,
    x = perCopy_save_l,
    file = fileNames
)

#Extract sequences corresponding to bed from fasta
seqs <- mcMap(
    f = seqtk, 
    fas =  sub("-.*",".TEs.fasta", sub("TEs/copies_allblastx/", "RepeatMasker/copies/", fileNames)),
    bed = fileNames,
    out = sub(".txt",".fasta", fileNames),
    mc.cores = 20,
    mc.preschedule = F
)
# check that we have the right number of copies with: cat TEs/copies_allblastx/*fasta | grep -c ">" : 23327765 copies 

# to select TE-TE hits that cover a protein region that is long enough,
# we need to get the blastn coordinates where starts always < ends
TEhits[, c("qSt", "qEn", "sSt", "sEn") := data.table(
    pmin(qStart, qEnd),
    pmax(qStart, qEnd),
    pmin(sStart, sEnd),
    pmax(sStart, sEnd)
    )]

# we add protein ranges for query and subject in blastn hits
TEhits[, c("qS", "qE", "superF_blastx.1") := perCopy[chmatch(copie1, query), .(start, end, superF_blastx)]]
TEhits[, c("sS", "sE", "superF_blastx.2") := perCopy[chmatch(copie2, query), .(start, end, superF_blastx)]]

# we prevent bugs that are caused by NAs in intersection()
TEhits[is.na(qS), c("qS", "qE") := 0L]
TEhits[is.na(sS), c("sS", "sE") := 0L]

# we get the region of the query that aligns on the subjects and also aligns on proteins
TEhits[, c("qS", "qE") := data.table(intersection(qSt, qEn, qS, qE, T))]
TEhits[, c("sS", "sE") := data.table(intersection(sSt, sEn, sS, sE, T))] # same, for the subject

# converts the above into query coordinates
TEhits[, c("qsS", "qsE") := .(qSt + sS - sSt, qEn + sE - sEn)]

# so we can compute the lenght of the TE alignment that also aligns on proteins
TEhits[, inter := pmin(qE, qsE) - pmax(qS, qsS) + 1L]
TEhits[is.na(inter) | inter < 0L, inter := 0L]

# we remove columns we no longer need
TEhits[, c("qSt", "qEn", "sSt", "sEn", "qS", "qE", "sS", "sE", "qsS", "qsE") := NULL]

# and with sufficient protein region (300 bp)
TEhitsCoveringProteins <- TEhits[inter >= 300L] 

# Look at percentage of hits for which the superfamilies of copy 1 & 2 are the same ones
TEhitsCoveringProteins[,mean(superF_blastx.1==superF_blastx.2, na.rm=T)]

# Select these hits
TEhitsCoveringProteins <- TEhitsCoveringProteins[superF_blastx.1 == superF_blastx.2] 

# Save
write.table(TEhitsCoveringProteins, "all300aa.txt", row.names = F, na = "NA",  sep = "\t")

# there are still too many hits to compute dS on.
# We select among redundant hits that may represent the same HTT. ---------------------------------------
# This is based on the fact that many hits share a copy (see Method section).

# we place the best hits on top (longest protein region then higher score)
setorder(TEhitsCoveringProteins, -inter, -score)

# we add an integer column denoting the single-linkage cluster of copies, based on hits
TEhitsCoveringProteins[, cl := clusterFromPairs(copie1, copie2)]

# we add an integer column indicating number of times we have seen a cluster for each a species pair.
# Within a species pair, hits of the same cluster would represent the same transfer and are thus redundant.
TEhitsCoveringProteins[, occ := occurrences(data.table(cl, assembly1, assembly2))]

summary = mutate(TEhitsCoveringProteins, pairs = paste0(assembly1, "-", assembly2)) %>%
    group_by(cl, pairs) %>%
    summarize(nbHit=n())


# we select at most 2000 hits between copies from a given cluster for any species pair
sel <- TEhitsCoveringProteins[occ <= 2000L, ]

# we also add an integer column for the mrca of each species pair, for later use
allPairs <- fread("Busco/pairsALL.txt")
sel1 <- mutate(sel, assembly.1 = sub("[.].*", "", assembly1),  assembly.2 = sub("[.].*", "", assembly2)) %>%  #write assembly like in allPairs, ie no version
    left_join(., allPairs) %>% #join both table to add mrca and species names
    select(., -c("assembly.1", "assembly.2")) %>%  #we don't need that anymore (we already have assembly1 & assembly2 with versions)
    rename(., species.1="sp1", species.2="sp2") %>% #we rename these column like there were with the previous method
    filter(., !is.na(mrca)) #we remove those that are not in this order in allPairs
#We do the same thing for those in order assembly2 - assembly1
sel2 = mutate(sel, assembly.2=sub("[.].*", "", assembly1),  assembly.1=sub("[.].*", "", assembly2)) %>%  #we exchnage assembly1 & assembly2
    left_join(., allPairs) %>% 
    select(., -c("assembly.1", "assembly.2")) %>% 
    rename(., species.1="sp1", species.2="sp2") %>% 
    filter(., !is.na(mrca)) #we remove those that are not in this other order in allPairs
sel = rbind(sel1, sel2)
    

# and write the filtered hits to disk
write.table(sel, "allOCC2000.txt", col.names = T, row.names = F, na = "NA",  sep = "\t", quote=F) 
