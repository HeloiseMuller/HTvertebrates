

## %######################################################%##
#                                                           #
####     This stage clusters TE-TE hits iteratively      ####
####       to delinate HTT events ("hit groups")         ####
#                                                           #
## %######################################################%##


# This stage is the first step where clusters hits from the same pair of "young"
# clades: clades of less than 40 My, in which we did not even look for HTT and
# did not measure any BUSCO Ks. Then we will aggregate the clusters that may
# reflect the same HTT. Clustering and aggregation will be based on criterion 1:
# pID of TEs between clade is lower than pID within clades

library(data.table)
library(Biostrings)
library(dplyr)
library(stringi)
library(stringr)
library(igraph) #for function graph_from_data_frame
library(ape)


path = "~/Project/"
setwd(path) 

source("HTvFunctions.R")

# this script uses:
# - the tabular file of selected TE-TE hit ("HTT hits") from stage 07-TEdSAndHTTfilter.R
httHits <- fread("TEs/clustering/dcMegablast/occ200ds05_dcMegablast.txt")
# - the self-blastn output generated by 08-prepareClustering.R (used later)

# the output will be a tabular file of HTT hits with a new column attributing a community number to each

###################################
###################################

# STEP ONE, we swap query and subject species in the TE-TE hit table 

# An HTT Involves two clades,
# We compare TE copies within clade to evaluate criterion 1. To do this, it is
# easier to swap sp1 and sp2 so that sp1 always corresponds to the same clade
# (and sp2 to the other) among the two sister clades that diverged from an MRCA.
# So we will compare "queries" (copies from the left-hand clade of the table) with each others
# and "subjects" (copies from the right-hand clade) with each others (not queries
# to subjects, that is already done with the pID in the HTT hits) so for each hit
# between species coalescing to an MRCA, we find its clade (the one among the two
# that diverged from the mrca)

tree <- read.tree("tree.nwk")

# the different MRCAs of the two species involved in each HTT hits
mrcas <- httHits[, unique(mrca)]

# this 2-column table gives the children (subclades, in column V2) of each node (MRCA, column V1)
edges <- data.table(tree$edge)

# these nodes are the subclades of each mrca in the httHits
subClades <- edges[V1 %in% mrcas, V2]

# we retrieve the species of these subclades
subClades <- tipsForNodes(tree, subClades, names = T)

# and the parent node (mrca) of each subclade
subClades[, MRCA := edges[match(node, V2), V1]]

# we combine tip (species) name and MRCA number, to match these combinations in the httHits
subClades[, comb := stri_c(tip, MRCA, sep = " ")]

# We assign subclade numbers (node numbers of the tree) to species in each hit, 
httHits[, c("cladeA", "cladeB") := .(
    subClades[chmatch(stri_c(species.1, mrca, sep = " "), comb), node],
    subClades[chmatch(stri_c(species.2, mrca, sep = " "), comb), node]
    )]

# and we ensure that the subclade with lower number is always on the left.
# This requires swapping many columns of the table:
httHits[cladeA > cladeB, c("ID.1", "ID.2", "species.1", "species.2", "qStart", "qEnd", "sStart", "sEnd", "copie1", "copie2", "assembly.1", "assembly.2", "TEconsensus.1", "TEconsensus.2", "cladeA", "cladeB")
:= .(ID.2, ID.1, species.2, species.1, sStart, sEnd, qStart, qEnd,  copie2, copie1, assembly.2, assembly.1, TEconsensus.2, TEconsensus.1, cladeB, cladeA)]


# saved to disk
fwrite(httHits, "occ200_subClades.txt", sep="\t")

###################################
###################################

#Compared to the scripts of Zhang et al. 2020, we deleted their step TWO
#This is because we organized our selftblasts differently

# STEP TWO, clustering of hits according to criterion 1
# we cluster hits between species of the same pair of "young" clades that
# diverged within the last 40 My. Within these clades, we did not even search for
# HTT (no blast) and we didn't even measure dS at busco genes. These clusters of hits will
# be the initial ones (the "communities") that we will aggregate in a second round
# so we assign species involved hits to the young clades

# the young clades of <40 My
clades <- cladesOfAge(tree, 40, withTips = T) 

# assigning species to these clades
httHits[, c("C1", "C2") := .(clades[chmatch(species.1, tip), node], clades[chmatch(species.2, tip), node])]

# To cluster hits, we prepare a table with only the columns we need.
# clustering of hits will be done within each "group" (hits involving a given pair of young clades in a super family).
# Hits will be identified by their row indices. We again replace slashes in super family names with periods
httHits[, "group" := .(stri_c(stri_replace(rep_superF.1, ".", fixed = "/"), C1, C2, sep = "_"))]

# We get the column we need for the clustering
conv <- httHits[, data.table(hit,

    # we convert blast pIDs to integers for efficiency in the clustering
    pID = as.integer(pID * 1000L),
    group,
    query = ID.1,
    subject = ID.2,
    mrca = mrca
)]


# we split these hits according to "groups"
hitList <- split(conv, conv$group)
hitList <- hitList[order(-sapply(hitList, nrow))]

# if there is just one hit in a group, no clustering needs to be done so we can remove the group
hitList <- hitList[sapply(hitList, nrow) > 1L]


# where results will go
dir.create("TEs/clustering/round1/")

# hitList will be used in the clustering jobs. Below we plan the jobs:
saveRDS(hitList, file = "TEs/clustering/round1/hitsForFirstClusteringdS05occ200.RDS")

groupList <- data.table(
    group = names(hitList),

    # number of hits to cluster per "group"
    nHits = sapply(hitList, nrow),
    superF = splitToColumns(names(hitList), "_", column=1),
    mrca = sapply(hitList, function(x){unique(x$mrca)})
)

#I do per super F & mrca, like this I have to open each file only once
perSuperF_mrca <- groupList[, .(nHits = sum(nHits), .N), by = list(superF, mrca)] 
#nHits is the number of hits for this superF-mrca, N is the number of group for this superF-mrca

#Put everyone in the batch n°0 to start
perSuperF_mrca[, batch := 0L]
#Those with more than 30000 hits get their own batch
perSuperF_mrca[nHits > 30000, batch := 1:.N] 

#As a consequence, all batches other than 0 include a unique superF and a unique mrca
#Batch 0 has all the others, so a mix of superF and a mix of mrca

length(unique(perSuperF_mrca$batch)) #29 batches in my case

#NOTE: if too many hits in a batch, would lead to error
#One may want to put some in another batch
#E.g. I gave its own batch to node 248 :
#perSuperF_mrca[batch==0 & mrca==248, batch:=30]

# this table will be used to manage jobs in iterativeFirstClustering.R
fwrite(perSuperF_mrca, "TEs/clustering/round1/batchesdS05occ200.txt", sep='\t')


# We can now run iterative fast clustering
# Either run it as many time as batches. 
    #eg to run batch n°0 with 5 CPU :
system("Rscript 09bis-iterativeFirstClustering.R 0 5")
# Or give a list of batch to run, separated by a comma
    #I have not try this way

#In anycase, the script iterativeFirstClustering.R can be quite long to run on some batch
#One might prefer to run it outside R, in background
# eg: nohup Rscript iterativeFirstClustering.R 0 5 &> nohup_iterativeFirstClustering_job0 &

###################################
###################################

# STEP THREE, we collect the results of the clustering
# there is one clustering output per job, we list them and import them
files <- list.files(
    path = "TEs/clustering/round1",
    pattern = "allGroups.txt",
    full.names = T
)

groups <- rbindlist(lapply(files, fread, header = T, sep = "\t"))

# we generate unique integer community ids (accross all groups)
groups[, ucomm := toInteger(string = stri_c(comm,
    group,
    sep = " "
))]

# we add these identifiers to the HTT hit table
httHits = left_join(httHits, select(groups, c(hit, ucomm)), by="hit") %>% rename(., "com"=ucomm) 

# the com column is NA for hits were not even clustered because there are just one per
# super family and clade pair, so we give them unique community numbers.
httHits[is.na(com), com := 1:.N + max(groups$ucomm)]


# write the new HTT hit table to disk
fwrite(httHits, "occ200ds05_comm_perClade.txt", sep='\t')